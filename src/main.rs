use crossbeam::queue::ArrayQueue;
use std::io::ErrorKind;
use std::net::{Ipv4Addr, SocketAddrV4};
use std::sync::Arc;
use std::time::Duration;

type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

use pnet::packet::{
    icmp::{
        echo_reply::EchoReplyPacket, echo_request::EchoRequestPacket,
        echo_request::MutableEchoRequestPacket, IcmpCode, IcmpPacket, IcmpTypes,
    },
    ipv4::Ipv4Packet,
    ipv4::MutableIpv4Packet,
    MutablePacket, Packet, PacketSize,
};
use socket2::{Domain, Protocol, SockAddr, Socket, Type};
use tokio::task::JoinSet;

const MIN_ICMP_PACKET_SIZE: usize = MutableEchoRequestPacket::minimum_packet_size();
const IPV4_HEADER_LENGTH: usize = MutableIpv4Packet::minimum_packet_size();
const IPV4_PACKET_LENGTH: usize = MIN_ICMP_PACKET_SIZE + IPV4_HEADER_LENGTH;

type Ipv4Buf = [u8; IPV4_PACKET_LENGTH];

async fn send(s: Arc<Socket>, q: Arc<ArrayQueue<Ipv4Buf>>, seq: u16) -> usize {
    let mut ipv4_buf = loop {
        //println!("trying queue for packet {}", seq);
        match q.pop() {
            Some(b) => break b,
            None => {
                tokio::time::sleep(Duration::from_millis(1)).await;
            }
        }
    };

    update_icmp_request_packet(&mut ipv4_buf, seq);

    let bytes_sent = loop {
        //println!("looping");
        match s.send(&ipv4_buf) {
            Err(e) => {
                if e.kind() == ErrorKind::WouldBlock {
                    tokio::time::sleep(Duration::from_millis(1)).await;
                } else {
                    panic!("unhandled socket send error: {}", e);
                }
            }
            Ok(length) => {
                println!("sent {} bytes for packet {}", length, seq);
                break length;
            }
        }
    };
    loop {
        //println!("pushing packet buffer back onto queue");
        match q.push(ipv4_buf) {
            Ok(_) => break,
            Err(b) => {
                tokio::time::sleep(Duration::from_millis(1)).await;
                ipv4_buf = b;
            }
        }
    }

    return bytes_sent;
}

#[tokio::main]
async fn main() -> Result<()> {
    let count: u16 = 5;
    let interval: u64 = 500;
    let timeout: Option<Duration> = Some(Duration::from_millis(5000));

    let ipv4_addr: Ipv4Addr = "1.1.1.1".parse().expect("should work, right?");
    let addr: SockAddr = SocketAddrV4::new(ipv4_addr, 0).into();
    let socket = Arc::new(Socket::new(
        Domain::IPV4,
        Type::RAW,
        Some(Protocol::ICMPV4),
    )?);
    socket.set_nonblocking(true)?;
    socket.set_write_timeout(timeout)?;
    socket.set_read_timeout(timeout)?;
    socket.connect(&addr)?;
    //println!("connected");

    let mut interval = tokio::time::interval(Duration::from_millis(interval));

    let mut set = JoinSet::new();

    // preallocate Ipv4 packets so we can avoid allocating memory on every asynchronous send.
    let queue: ArrayQueue<Ipv4Buf> = ArrayQueue::new(10);
    for _ in 0..9 {
        let mut ipv4_buf = [0u8; IPV4_PACKET_LENGTH];
        // println!("min icmp packet size: {}", MIN_ICMP_PACKET_SIZE);
        // println!("ipv4 header length: {}", IPV4_HEADER_LENGTH);
        // println!("ipv4 packet size: {}", ipv4_buf.len());
        {
            // as long as we're pre-allocating ipv4 packets, we may as wellwalso pre-populate ipv4
            // and icmp fields that will be common among all packets
            let mut ipv4_packet = MutableIpv4Packet::new(&mut ipv4_buf)
                .expect("the buf size is set to the minimum packet size");
            ipv4_packet.set_destination(ipv4_addr);
            ipv4_packet.set_header_length(IPV4_HEADER_LENGTH as u8);

            // if we don't set the total length here, then setting the payload will fail due to
            // jankiness in the set_payload function generated by pnet's packet macro that looks at
            // the declared packet length.
            //
            // this makes me think that it's probably not such a great idea to use socket2 as
            // suggested in the exercise but to instead use pnet's own transport channels, which
            // look like they do a good job of abstracting over IPV4 details
            ipv4_packet.set_total_length(IPV4_PACKET_LENGTH.try_into().expect(""));

            let mut icmp_buf = [0u8; MIN_ICMP_PACKET_SIZE];
            //println!("icmp buf size: {}", icmp_buf.len());
            {
                let mut icmp_packet = MutableEchoRequestPacket::new(&mut icmp_buf)
                    .expect("the buf size should be exactly the minimum icmp packet size");
                icmp_packet.set_icmp_type(IcmpTypes::EchoRequest);
                icmp_packet.set_icmp_code(IcmpCode(0));
                icmp_packet.set_identifier(42);
                //println!("icmp_packet size: {}", icmp_packet.packet_size());
            }
            //println!("ipv4 header length: {}", ipv4_packet.get_header_length());
            //println!(
            //    "ipv4 packet size (without payload): {}",
            //    ipv4_packet.packet_size()
            //);
            ipv4_packet.set_payload(&icmp_buf);
        }
        queue
            .push(ipv4_buf)
            .expect("don't push more than the queues capacity");
    }

    let queue = Arc::new(queue);
    //println!("queue configured");

    for i in 0..count {
        println!("sending packet {}", i);
        interval.tick().await;
        let s = socket.clone();
        let q = queue.clone();
        // send asynchronously
        set.spawn(async move { send(s, q, i).await });
        // receive responses asynchronously
    }

    while set.join_next().await.is_some() {}

    Ok(())
}

/// Updates the given ipv4 buffer with the current icmp sequence, the new icmp checksum, and the
/// new ipv4 checksum.
fn update_icmp_request_packet(ipv4_buf: &mut [u8; IPV4_PACKET_LENGTH], seq: u16) {
    {
        let mut ipv4_packet = MutableIpv4Packet::new(ipv4_buf)
            .expect("the buf size is set to the minimum packet size");

        let mut icmp_buf = ipv4_packet.payload_mut();
        let mut icmp_packet = MutableEchoRequestPacket::new(&mut icmp_buf)
            .expect("the buf size should be exactly the minimum icmp packet size");
        icmp_packet.set_sequence_number(seq);

        let checksum =
            pnet::packet::icmp::checksum(&IcmpPacket::new(icmp_packet.packet()).expect("TODO"));
        icmp_packet.set_checksum(checksum);
    }

    let checksum = { pnet::packet::ipv4::checksum(&Ipv4Packet::new(ipv4_buf).expect("TODO")) };

    let mut ipv4_packet =
        MutableIpv4Packet::new(ipv4_buf).expect("the buf size is set to the minimum packet size");
    ipv4_packet.set_checksum(checksum)
}
